name: Replace Evidence Keys

on:
  workflow_dispatch:
    inputs:
      private_key_content:
        description: 'Private Key Content (paste entire private.pem content)'
        required: true
        type: string
      public_key_content:
        description: 'Public Key Content (paste entire public.pem content)'
        required: true
        type: string
      key_alias:
        description: 'Key Alias (default: bookverse_evidence_key)'
        required: false
        default: 'bookverse_evidence_key'
        type: string
      update_jfrog_platform:
        description: 'Update JFrog Platform trusted keys'
        required: false
        default: true
        type: boolean

env:
  KEY_ALIAS: ${{ inputs.key_alias || 'bookverse_evidence_key' }}

jobs:
  replace_evidence_keys:
    runs-on: ubuntu-latest
    name: Replace Evidence Keys Across BookVerse
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Setup JFrog CLI
        if: ${{ inputs.update_jfrog_platform }}
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_ACCESS_TOKEN: ${{ secrets.JFROG_ADMIN_TOKEN }}

      - name: Validate key inputs
        run: |
          echo "üîç Validating evidence key inputs..."
          
          # Check if inputs are provided
          if [[ -z "${{ inputs.private_key_content }}" ]]; then
            echo "‚ùå Private key content is required"
            exit 1
          fi
          
          if [[ -z "${{ inputs.public_key_content }}" ]]; then
            echo "‚ùå Public key content is required"
            exit 1
          fi
          
          # Normalize and create temporary files for validation
          echo "üîß Processing key formats..."
          
          # First, detect if keys already have proper line breaks
          PRIVATE_HAS_NEWLINES=$(echo '${{ inputs.private_key_content }}' | grep -c $'\n' || echo "0")
          PUBLIC_HAS_NEWLINES=$(echo '${{ inputs.public_key_content }}' | grep -c $'\n' || echo "0")
          
          echo "üîç Private key has $PRIVATE_HAS_NEWLINES line breaks"
          echo "üîç Public key has $PUBLIC_HAS_NEWLINES line breaks"
          
          # Create temporary files with proper handling
          if [[ "$PRIVATE_HAS_NEWLINES" -gt 1 ]]; then
            echo "‚úÖ Private key already has proper formatting"
            cat << 'EOF' > private.pem
${{ inputs.private_key_content }}
EOF
          else
            echo "üîß Normalizing private key format..."
            # Normalize private key: replace spaces between header/content/footer with newlines
            echo '${{ inputs.private_key_content }}' | \
              sed 's/-----BEGIN PRIVATE KEY----- /-----BEGIN PRIVATE KEY-----\n/g' | \
              sed 's/ -----END PRIVATE KEY-----/\n-----END PRIVATE KEY-----/g' | \
              sed 's/-----BEGIN RSA PRIVATE KEY----- /-----BEGIN RSA PRIVATE KEY-----\n/g' | \
              sed 's/ -----END RSA PRIVATE KEY-----/\n-----END RSA PRIVATE KEY-----/g' | \
              sed 's/-----BEGIN EC PRIVATE KEY----- /-----BEGIN EC PRIVATE KEY-----\n/g' | \
              sed 's/ -----END EC PRIVATE KEY-----/\n-----END EC PRIVATE KEY-----/g' | \
              sed 's/\([A-Za-z0-9+/=]\{64\}\) /\1\n/g' > private.pem
          fi
          
          if [[ "$PUBLIC_HAS_NEWLINES" -gt 1 ]]; then
            echo "‚úÖ Public key already has proper formatting"
            cat << 'EOF' > public.pem
${{ inputs.public_key_content }}
EOF
          else
            echo "üîß Normalizing public key format..."
            # Normalize public key: replace spaces between header/content/footer with newlines  
            echo '${{ inputs.public_key_content }}' | \
              sed 's/-----BEGIN PUBLIC KEY----- /-----BEGIN PUBLIC KEY-----\n/g' | \
              sed 's/ -----END PUBLIC KEY-----/\n-----END PUBLIC KEY-----/g' | \
              sed 's/-----BEGIN RSA PUBLIC KEY----- /-----BEGIN RSA PUBLIC KEY-----\n/g' | \
              sed 's/ -----END RSA PUBLIC KEY-----/\n-----END RSA PUBLIC KEY-----/g' | \
              sed 's/\([A-Za-z0-9+/=]\{64\}\) /\1\n/g' > public.pem
          fi
          
          echo "üìã Private key preview (first 3 lines):"
          head -3 private.pem
          echo "üìã Private key preview (last 3 lines):"
          tail -3 private.pem
          echo ""
          echo "üìã Public key preview (first 3 lines):"
          head -3 public.pem
          echo "üìã Public key preview (last 3 lines):"
          tail -3 public.pem
          echo ""
          echo "üîç File sizes:"
          echo "Private key: $(wc -c < private.pem) bytes, $(wc -l < private.pem) lines"
          echo "Public key: $(wc -c < public.pem) bytes, $(wc -l < public.pem) lines"
          
          # Validate private key format with detailed error reporting
          echo "üîç Validating private key format..."
          if ! openssl pkey -in private.pem -check -noout 2>private_error.log; then
            echo "‚ùå Invalid private key format"
            echo "üêõ OpenSSL error details:"
            cat private_error.log
            echo ""
            echo "üîç Raw private key file content (first 200 chars):"
            head -c 200 private.pem | cat -A
            exit 1
          fi
          echo "‚úÖ Private key format is valid"
          
          # Validate public key format with detailed error reporting
          echo "üîç Validating public key format..."
          if ! openssl pkey -in public.pem -pubin -check -noout 2>public_error.log; then
            echo "‚ùå Invalid public key format"
            echo "üêõ OpenSSL error details:"
            cat public_error.log
            echo ""
            echo "üîç Raw public key file content (first 200 chars):"
            head -c 200 public.pem | cat -A
            exit 1
          fi
          echo "‚úÖ Public key format is valid"
          
          # Verify key pair match
          private_pubkey=$(openssl pkey -in private.pem -pubout 2>/dev/null)
          public_key_content=$(cat public.pem)
          
          if [[ "$private_pubkey" != "$public_key_content" ]]; then
            echo "‚ùå Private and public keys do not match"
            exit 1
          fi
          
          echo "‚úÖ Key validation successful"
          echo "üîë Key type: $(openssl pkey -in private.pem -text -noout 2>/dev/null | head -1)"
          echo "üè∑Ô∏è  Key alias: $KEY_ALIAS"

      - name: Replace evidence keys in repositories
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üîß Preparing normalized key content for distribution..."
          
          # Read the normalized keys from the validation step
          PRIVATE_KEY_CONTENT=$(cat private.pem)
          PUBLIC_KEY_CONTENT=$(cat public.pem)
          
          # Export for the script
          export PRIVATE_KEY_CONTENT
          export PUBLIC_KEY_CONTENT
          
          ./.github/scripts/setup/replace_evidence_keys.sh

      - name: Update JFrog Platform trusted keys
        if: ${{ inputs.update_jfrog_platform }}
        env:
          JFROG_CLI_LOG_LEVEL: INFO
        run: |
          echo "üì§ Updating JFrog Platform trusted keys..."
          
          # Read the normalized public key
          PUBLIC_KEY_CONTENT=$(cat public.pem)
          
          # Prepare public key content for JSON (escape newlines and quotes)
          PUBLIC_KEY_JSON=$(echo "$PUBLIC_KEY_CONTENT" | sed 's/"/\\"/g' | awk '{printf "%s\\n", $0}' | sed 's/\\n$//')
          
          # Create JSON payload
          JSON_PAYLOAD=$(cat << EOF
          {
            "alias": "$KEY_ALIAS",
            "public_key": "$PUBLIC_KEY_JSON"
          }
          EOF
          )
          
          echo "üîç Uploading public key with alias: $KEY_ALIAS"
          
          # Upload to JFrog Platform
          RESPONSE=$(curl -s -w "\n%{http_code}" \
            -X POST \
            -H "Authorization: Bearer ${{ secrets.JFROG_ADMIN_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data-binary "$JSON_PAYLOAD" \
            "${{ vars.JFROG_URL }}/artifactory/api/security/keys/trusted")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE_BODY=$(echo "$RESPONSE" | head -n -1)
          
          if [[ "$HTTP_CODE" == "200" ]] || [[ "$HTTP_CODE" == "201" ]]; then
            echo "‚úÖ Successfully uploaded public key to JFrog Platform"
            echo "üìã Response: $RESPONSE_BODY"
            
            # Parse and display key information
            if command -v jq >/dev/null 2>&1; then
              echo "üîë Key fingerprint: $(echo "$RESPONSE_BODY" | jq -r '.fingerprint // "N/A"')"
              echo "üÜî Key ID: $(echo "$RESPONSE_BODY" | jq -r '.kid // "N/A"')"
            fi
          else
            echo "‚ùå Failed to upload public key to JFrog Platform"
            echo "üìã HTTP Code: $HTTP_CODE"
            echo "üìã Response: $RESPONSE_BODY"
            exit 1
          fi

      - name: Verify evidence key deployment
        run: |
          echo "üîç Verifying evidence key deployment..."
          
          # Check GitHub secrets and variables
          echo "üìã Checking GitHub repository configurations..."
          
          REPOS=(
            "bookverse-inventory"
            "bookverse-recommendations" 
            "bookverse-checkout"
            "bookverse-platform"
            "bookverse-web"
            "bookverse-helm"
            "bookverse-demo-assets"
            "bookverse-demo-init"
          )
          
          for repo in "${REPOS[@]}"; do
            echo "  üì¶ Checking $repo..."
            
            # Check if private key secret exists
            if gh secret list --repo "yonatanp-jfrog/$repo" | grep -q "EVIDENCE_PRIVATE_KEY"; then
              echo "    ‚úÖ EVIDENCE_PRIVATE_KEY secret exists"
            else
              echo "    ‚ùå EVIDENCE_PRIVATE_KEY secret missing"
            fi
            
            # Check if public key variable exists
            if gh variable list --repo "yonatanp-jfrog/$repo" | grep -q "EVIDENCE_PUBLIC_KEY"; then
              echo "    ‚úÖ EVIDENCE_PUBLIC_KEY variable exists"
            else
              echo "    ‚ùå EVIDENCE_PUBLIC_KEY variable missing"
            fi
            
            # Check if alias variable exists
            if gh variable list --repo "yonatanp-jfrog/$repo" | grep -q "EVIDENCE_KEY_ALIAS"; then
              echo "    ‚úÖ EVIDENCE_KEY_ALIAS variable exists"
            else
              echo "    ‚ùå EVIDENCE_KEY_ALIAS variable missing"
            fi
          done

      - name: Generate summary
        run: |
          echo "üéâ Evidence Key Replacement Complete!"
          echo "====================================="
          echo ""
          echo "‚úÖ What was updated:"
          echo "  ‚Ä¢ EVIDENCE_PRIVATE_KEY secrets in all 8 repositories"
          echo "  ‚Ä¢ EVIDENCE_PUBLIC_KEY variables in all 8 repositories"
          echo "  ‚Ä¢ EVIDENCE_KEY_ALIAS variables in all 8 repositories"
          if [[ "${{ inputs.update_jfrog_platform }}" == "true" ]]; then
            echo "  ‚Ä¢ JFrog Platform trusted keys registry"
          fi
          echo ""
          echo "üîë Key alias: $KEY_ALIAS"
          echo "üìã Repositories updated: 8 BookVerse repositories"
          echo ""
          echo "üéØ Next steps:"
          echo "  ‚Ä¢ Evidence signing will now use the new keys"
          echo "  ‚Ä¢ Run workflows to test evidence generation"
          echo "  ‚Ä¢ Verify evidence verification works correctly"
