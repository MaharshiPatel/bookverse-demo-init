### Repository Architecture and Naming (BookVerse)

Link: BookVerse playbook (`https://docs.google.com/document/d/1IJZDSFB_AtP4JDqHjWQ6z_geb--fngAnqup2TTGRNrw/edit?usp=sharing`).

### Goals
- Clear, repeatable structure for four services and shared assets
- Consistent naming across GitHub and Artifactory
- CI/CD that maps cleanly to AppTrust lifecycle: DEV → QA → STAGING → PROD

### GitHub repositories (per playbook)
- bookverse-inventory (service)
- bookverse-recommendations (service)
- bookverse-checkout (service)
- bookverse-platform (aggregations/shared libs)
- bookverse-web (UI assets as applicable)
- bookverse-helm (charts for environments)
- bookverse-demo-assets (datasets, shared workflows, runbook artifacts)

Optional: bookverse-infra (if infra automation is split).

### Artifactory repository keys (local)
- Internal (project stages): `${PROJECT_KEY}-{name}-internal-{package}-nonprod-local`
  - environments: `["bookverse-DEV","bookverse-QA","bookverse-STAGING"]`
- Release (PROD): `${PROJECT_KEY}-{name}-internal-{package}-release-local` (web/platform visibility varies)
  - environments: `["PROD"]` (PROD is global and not included in lifecycle APIs)

Where:
- `PROJECT_KEY = bookverse`
- `name ∈ {inventory,recommendations,checkout,platform,web,helm}`
- `package ∈ {docker,python,npm,maven,helm}`

Examples:
- Docker: `bookverse-inventory-internal-docker-nonprod-local`, `bookverse-inventory-internal-docker-release-local`
- Python (pypi): `bookverse-recommendations-internal-python-nonprod-local`
- npm (web): `bookverse-web-internal-npm-nonprod-local`, `bookverse-web-internal-npm-release-local`
- Maven (java): `bookverse-platform-public-maven-nonprod-local`
- Helm charts: `bookverse-helm-internal-helm-nonprod-local`

### Stage and lifecycle
- Project stages: `bookverse-DEV`, `bookverse-QA`, `bookverse-STAGING`
- Global release stage: `PROD` (always last; do not send in lifecycle PATCH)
- Lifecycle promote order: DEV → QA → STAGING → PROD

### Publish targets by ecosystem
- Docker:
  - Registry: `<JFROG_URL_HOST>` (e.g., `z0apptrustdev.jfrogdev.org`)
  - Repo: `${PROJECT_KEY}-{name}-docker-{internal|release}-local`
  - Image: `<JFROG_URL_HOST>/${PROJECT_KEY}-{name}-docker-{internal|release}-local/{name}:{version}`
- Python (pypi):
  - Package: `bookverse-{name}`
  - Repo: `${PROJECT_KEY}-{name}-python-{internal|release}-local`
- npm:
  - Scope: `@bookverse/{name}`
  - Repo: `${PROJECT_KEY}-{name}-npm-{internal|release}-local`
- Maven:
  - Group: `com.bookverse`
  - Repo: `${PROJECT_KEY}-{name}-maven-{internal|release}-local`
- Helm:
  - Chart: `{name}`
  - Repo: `${PROJECT_KEY}-{name}-helm-{internal|release}-local`

### Service repo structure (per repo)
```
.
├─ src/
│  └─ bookverse_{service}/
├─ tests/
├─ Dockerfile
├─ pyproject.toml (or requirements.txt)
├─ .github/
│  └─ workflows/
│     ├─ ci.yml
│     └─ promote.yml
└─ README.md
```

### GitHub Actions (per service)
- `ci.yml`
  - Checkout → setup-python → install deps → tests
  - Build artifact:
    - Python: wheel/sdist
    - Node: package tarball
    - Java: jar
    - Docker: image
  - Collect provenance and metadata:
    - Capture commit author/email and committer (git) into build-info
    - Record reviewer(s) metadata (for demo: can be synthetic/faked)
    - Generate SLSA provenance attestation (can be synthetic/faked) and attach
    - Note: Application SBOM is automatically generated by JFrog AppTrust — do not generate/sign SBOMs in CI
  - OIDC login to JFrog (no stored tokens)
  - Publish artifacts:
    - Branch builds → internal repos
    - Tagged releases (e.g., `vX.Y.Z`) → release repos (PROD)
- `promote.yml`
  - Workflow dispatch with `target_stage` (QA or STAGING or PROD)
  - Preconditions: artifact exists in source stage; lifecycle order respected
  - Promote/move artifacts; for PROD use release repos
  - Attach promotion evidence (can be synthetic): QA test summary, approvals, change ticket/reference
  - Emit build-info and notifications

### Branching, tagging, and versions
- Default branch: `main`
- SemVer tags `vX.Y.Z` trigger release packaging and publication to `*-release-local`
- Non-tag builds publish to `*-internal-local` with commit SHA labels/metadata

### OIDC and identity mapping
- One OIDC integration per service (name: `github-bookverse-{service}`)
- Issuer: `https://token.actions.githubusercontent.com/`
- Subject filter examples:
  - `repo:{org}/bookverse-{service}:ref:refs/heads/*` for branches
  - `repo:{org}/bookverse-{service}:ref:refs/tags/*` for tags
- Map to project `bookverse` and allow publish to the service’s repos

### Required variables (per service repo)
- Repository variables (no secrets needed with OIDC):
  - `PROJECT_KEY=bookverse`
  - `JFROG_URL` (e.g., `https://z0apptrustdev.jfrogdev.org`)
  - `DOCKER_REGISTRY` (host portion of `JFROG_URL`, for Docker)
  - Optional per-ecosystem toggles (e.g., `ENABLE_NPM`, `ENABLE_MAVEN`, etc.)

### Demo assets repo (bookverse-demo-assets)
- Store datasets, SBOMs, policy files, re-usable workflow composites, screenshots, and the presenter runbook.

### Validation checklist (per repo)
- CI publishes to internal repos with environments `[bookverse-DEV, bookverse-QA, bookverse-STAGING]`
- Tag release publishes to release repo with environments `[PROD]`
- OIDC access works (no PAT)
- Build-info present; SBOM and signatures attached
- Repo families exist for each required ecosystem per service (docker/python/npm/maven/helm)

### Notes
- Stage names must be project-prefixed; `PROD` is global and excluded from lifecycle API payloads.
- Verbosity: scripts support 0 (silent), 1 (feedback, default), 2 (debug with obfuscated tokens).


